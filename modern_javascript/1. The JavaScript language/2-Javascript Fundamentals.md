# [JavaScript Fundamentals](https://javascript.info/first-steps)

## 2.1) [Hello, world!](https://javascript.info/hello-world)

### 웹 페이지에 스크립트를 삽입하는 방법

#### 1. script 태그

\<script> 태그 안에 자바스크립트를 작성하는 방식을 이용하면 자바스크립트를 HTML 문서 어느 곳에나 삽입할 수 있다.

```html
<!DOCTYPE HTML>
<html>
<body>
  <p>somethingsomething</p>
  <script>
    alert( 'Hello, world!' );
  </script>
  <p>somethingsomething</p>
</body>
</html>
```

브라우저는 `<script>` 태그를 만나면 그 안의 코드를 자동으로 처리한다.

#### 2. 외부 스크립트

자바스크립트 코드의 양이 많은 경우, 외부 파일에 별도로 자바스크립트를 분리해 저장한 뒤 각 파일을 `src` 속성을 사용해 HTML에 삽입할 수 있다.

```html
<!--절대 경로, 상대 경로 둘 다 사용 가능-->
<script src="/path/to/script.js"></script>
<!--URL 사용 가능-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>
<!--script 태그는 src 속성과 내부 코드를 동시에 가지지 못함-->
<script src="file.js">
  alert(1); // src 속성이 사용되면 태그 안의 코드는 무시됨
</script>
```

### 어떤 방식이 더 좋은가?

 `<script>` 태그를 통해 HTML 안에 직접 스크립트를 작성하는 방식은 스크립트가 아주 간단할 때만 사용하는 것이 좋고, 스크립트가 길어지면 별개의 분리된 파일로 만들어 저장하는 것이 좋다.

그 이유는 캐시 때문인데, 스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 캐시에 저장하기에 성능상의 이점이 있다. 여러 페이지에서 동일한 스크립트를 사용하는 경우 페이지가 바뀔 때마다 스크립트를 새로 다운받지 않고, 한 번만 다운받은 뒤 캐시에서 가져와 사용할 수 있기 때문이다. 트래픽 절약과 웹페이지 속도향상이 가능하다.



## 2.2) [Code structure](https://javascript.info/structure)

### 세미콜론

자바스크립트는 줄 바꿈을 암시적 세미콜론으로 해석하는 방식으로 작동한다. (세미콜론 자동 삽입) 따라서 대부분의 경우, 줄 바꿈이 세미콜론을 의미하기에 세미콜론을 생략할 수 있다. 그러나 일부 예외의 경우 줄 바꿈이 세미콜론을 의미하지 않는 경우도 있다.

세미콜론이 없어서 엔진이 코드를 잘못 해석할 시 생기는 버그는 고치기가 어렵다. 따라서 문 사이엔 세미콜론을 넣는 것을 규칙으로 권고한다. (안전하기 때문)



## 2.3) [The modern mode, "use strict"](https://javascript.info/strict-mode)

2009년 ES5가 등장하면서 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었다. 기존 기능을 변경하면서 하위 버전과의 호환성 문제가 생겼고, 따라서 변경사항 대부분은 ES5의 기본 모드에서는 활성화되지 않는다. 대신, `"use strict"`라는 특별한 지시자를 사용해 엄격 모드(strict mode)를 활성화 했을 때만 이 변경사항이 활성화된다.

### "use strict" 지시자

마치 문자열처럼 생겼지만, `"use strict"` 가 **스크립트 최상단**에 위치할 경우 스크립트 전체가 모던한 방식으로 동작한다. 스크립트 최상단이 아닌 함수 본문 맨 앞에 오면, 해당 함수만 엄격 모드로 실행되지만 이렇게 사용하는 경우는 흔치 않을 것이다.

`브라우저 콘솔에서 엄격 모드 적용하기`

기본적으로 브라우저 내 콘솔에는 엄격 모드가 적용되어 있지 않다. 아래와 같은 방법으로 엄격 모드에서 스크립트를 테스트 할 수 있다.

```javascript
'use strict'; <Shift+Enter를 눌러 줄 바꿈>
//  ...테스트하려는 코드 입력
<Enter를 눌러 실행>
```

`함수를 엄격 모드로 실행하기`

```javascript
(function() {
  'use strict';

  // ...테스트하려는 코드...
})()
```

우리는 modern javascript에 대해 배우고 있으므로, 항상 use strict 를 사용해 학습하도록 권장한다.
엄격 모드에서 달라지는 점은 다음과 같다.

- 자바스크립트 엔진을 “모던한” 모드로 전환해주며, 몇 가지 내장 기능의 동작 방식이 변경된다.
- 스크립트나 함수 본문 최상단에 위치한 "use strict" 지시자 외에도 클래스, 모듈과 같은 몇몇 기능은 자동으로 엄격 모드를 활성화한다.
- 모든 모던 브라우저는 엄격 모드를 지원한다



## 2.4) [Variables](https://javascript.info/variables)

### 변수 명명 규칙

자바스크립트의 변수 명명 제약 사항은 다음과 같다.

- 변수명에 올 수 있는 글자는 오직 문자, 숫자, 그리고 `$`, `_` 기호 뿐이다
- 변수명의 첫 글자는 숫자일 수 없다

이 외에, 자바스크립트의 변수명은 대소문자를 구별하며 예약어 목록에 있는 단어는 사용할 수 없다.

### 변수의 종류

let : 모던한 변수 선언 키워드
const : 모던한 상수 선언 키워드

### 대문자 상수

상수를 명명할 때 대문자와 `_` 기호로 구성된 이름으로 명명하는 경우가 있는데, 이러한 변수명 명명 방식은 일반적으로 **하드 코딩한 값의 별칭**을 만들 때 이용한다.

아래와 같이, 기억하기 힘든 컬러 코드 값을 변수에 할당해 별칭으로 사용하는 경우, 컬러 코드는 하드 코딩된 값이므로 대문자 상수 명명 방식을 따른다. 이렇게 하드 코딩된 값은 즉 코드가 실행되기 전에 이미 그 값을 알고 있는 값이다.

```js
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// 색상을 고르고 싶을 때 별칭을 사용할 수 있게 되었습니다.
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

반면, **런타임 과정에서 계산**되지만 최초 할당 이후 값이 변하지 않는 상수도 있다. 즉, 코드가 실행되기 전에 값을 알 순 없지만 (코드 실행 이후에 값이 할당되므로) 이후에 값이 변하지 않는 상수의 경우 일반적인 방식 (camelCase) 으로 변수명을 짓는다.

```js
const pageLoadTime = /* 웹페이지를 로드하는데 걸린 시간 */;
```

### 바람직한 변수명

변수 명명 시 참고하기 좋은 규칙은 다음과 같다.

- 줄임말이나 a,b,c 등의 짧은 이름은 피하기
- data, value 와 같이 아무것도 설명해주지 않는 변수명은 좋지 않다. 서술적이되 간결하게 명명하자.

### 변수 재사용 vs 새로 만들기

변수 선언이 귀찮아서 기존 변수를 재사용하는 경우가 있을 수 있다. 하지만, 변수를 재사용하는 것 보다는 새로운 변수를 추가하는 것이 더 좋다. 재사용된 변수는 과거에 붙여진 스티커를 떼지 않은 채 물건만 바뀐 상자와 같기 때문이다.

모던 자바스크립트 압축기(minifier)와 브라우저는 코드 최적화를 잘해주기에 변수를 추가한다고 해서 성능 이슈가 생기지 않는다. 그렇기 때문에 새로운 내용물에는 새로운 변수를 선언하도록 하자.



## 2.5) [Data types](https://javascript.info/types)

자바스크립트는 **동적 타입 언어**로, 자료의 타입은 존재하지만 변수에 저장되는 값의 타입은 언제든지 바뀔 수 있다.

### 숫자형 (number types)

- 정수 및 부동소수점 숫자
- 일반적인 숫자 외에  `Infinity`, `-Infinity`, `NaN` 과 같은 '특수 숫자 값(special numeric value)' 을 포함한다

`NaN` 은 계산 중에 에러가 발생했다는 것을 나타내주는 값이다. 말이 안되는 수학 연산 (문자열을 숫자로 나누는 등의) 을 하더라도 스크립트는 도중에 죽는 것이 아니라, NaN을 반환하며 연산을 종료하기에 안전하다.

`NaN` 에 어떤 추가적인 연산을 하더라도 NaN이 반환되기 때문에 연산 과정 어디에선가 NaN이 반환되었다면 이는 모든 결과에 영향을 미친다.

### BigInt

자바스크립트에선  `2^53` 보다 크거나  `-2^53` 보다 작은 정수는 숫자형을 사용해 나타낼 수 없다. (참고 - 해당 숫자들은 16자리 이상의 숫자들로 이루어진 정수이다. )

정수 리터럴 끝에 `n`을 붙여서 만들 수 있는 BigInt의 경우 길이에 상관 없이 정수를 나타낼 수 있다.

```js
// 끝에 'n'이 붙으면 BigInt형 자료이다
const bigInt = 1234567890123456789012345678901234567890n;
```

표준으로 채택된 지 얼마 안된 자료형으로, 호환성 이슈가 존재한다. (Firefox, Chrome에서만 지원)

### 문자형 (string)

자바스크립트의 문자열은 따옴표로 묶어 표현하며, 따옴표에는 세 종류가 있다.

1. 큰따옴표 : `"Hello"`
2. 작은따옴표 : `'Hello'`
3. 역 따옴표 (백틱, backtick) : \`Hello\`

큰따옴표와 작은따옴표는 차이가 없으며, 역 따옴표는 `${…}` 를 사용해 원하는 변수나 표현식을 문자열 중간에 넣을 수 있다.

### 불린형 (boolean)

`true` , `false` 두 가지 값만이 존재한다.

### null

자바스크립트에서는 `null` 값을

- 존재하지 않는(nothing) 값

- 비어 있는(empty) 값

- 알 수 없는(unknown) 값

을 나타내는 데 사용한다.

```js
let age = null; // 나이를 알 수 없거나, 그 값이 비어있음을 보여준다.
```

### undefined

자바스크립트에서는 `undefined` 값을 "값이 할당되지 않은 상태" 를 나타낼 때 사용한다.

변수를 선언만 하고, 값을 할당하지 않은 경우 해당 변수에 `undefined` 가 자동으로 할당된다.

```js
let x;

alert(x); // "undefined"
```

변수에 직접 undefined 를 할당하는 것도 가능하다지만 권장되지 않는다.

**변수가 비어있거나 값을 알 수 없는 경우를 나타내고 싶다면 null 을 사용**하고, 
**undefined는 변수에 값이 할당되었는지의 여부를 확인할 때 사용**해야 한다

### 객체형

객체형은 다른 자료형들 (원시 자료형, primitive type)과는 달리, 데이터의 컬렉션이나 복잡한 개체를 표현할 때 사용된다.

### 심볼형

객체의 고유한 식별자 (unique identifier) 를 만들 때 사용된다.

### 인수의 자료형을 반환하는 typeof 연산자

자료형에 따라 처리 방식을 다르게 하고 싶거나, 변수의 자료형을 알아내고자 할 때 `typeof` 연산자를 사용할 수 있다.

두 가지 형태의 문법으로 사용되며, 괄호에 무관하게 결과는 동일하다.

1. 연산자: `typeof x`
2. 함수: `typeof(x)`

피연산자가 함수일 경우 typeof 연산자는 "function" 을 반환하나, 함수는 객체형에 속함에 유의해야 한다. (함수형 자료형은 따로 존재하지 않는다.)



## 2.6) [Type Conversions](https://javascript.info/type-conversions)

자바스크립트에서 함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 형 변환된다. 명시적으로 전달받은 값을 원하는 타입으로 형 변환해 줄 수도 있다.

### 문자형 변환

```js
let value = true;
alert(typeof value); // boolean

value = String(value); // 문자형 "true" 으로 형 변환
alert(typeof value); // string
```

### 숫자형 변환

수학과 관련된 함수나 표현식에서 자동으로 일어난다.

```js
alert( "6" / "2" ); // 3
```

문자형변환과 마찬가지로 명시적으로 변환할 수 있다.

```js
let value = "123";
alert(typeof value); // string

value = Number(value); // 숫자형 123 으로 형 변환
alert(typeof value); // number
```

문자 기반 Form을 통해 입력받은 숫자형 값으로 연산을 하고자 하는 경우 이런 명시적 형 변환이 필수적이다.

### 불린형 변환

불린형으로의 변환은 논리 연산을 수행할 때 발생한다.

- 숫자 `0`, 빈 문자열, `null`, `undefined`, `NaN` 과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 `false` 로 변환된다.

- 그 외의 값은 `true` 로 변환된다.

불린형 역시 명시적 형 변환이 가능하다.

```js
let value = "1";
alert(typeof value); // string

value = Boolean(value); // 불린형(true)로 형 변환
alert(typeof value); // boolean
```



## 2.7) [Operators](https://javascript.info/operators)

모든 연산자는 값을 반환한다. 심지어 할당 연산자 `=` 역시도 값을 반환한다.

### 이항 연산자 +와 문자열 연결

자바스크립트에서 `+` 는 단순 덧셈이 아니라 문자열 연결 기능을 제공한다. 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환되어 병합된다.

```js
alert(2 + 2 + '1' ); // "41"
```

이렇듯 이항 연산자 `+` 는 다른 산술 연산자 (`/`, `-`) 와는 달리 특별한 문자열 연결 및 변환이라는 기능이 있음에 주의하자.

### 단항 연산자 + 와 숫자형으로의 변환

피연산자가 숫자가 아닌 경우, 피연산자에 `+` 를 붙이면 숫자형으로의 변환이 일어난다.

```js
// 숫자형이 아닌 피연산자가 숫자형으로 변화
alert( +true ); // 1
alert( +"" );   // 0
```

이처럼 단항 연산자 `+` 는 `Number(...)` 이 해주는 숫자형으로의 명시적 형변환과 동일한 역할을 수행한다.

아래 두 코드를 비교하면서 단항 연산자로 쓰이는 `+` 의 용례를 확인해보자.

```js
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23" 이항 덧셈 연산자는 문자열을 연결
```

```js
let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자가 숫자형으로 변화한다
alert( +apples + +oranges ); // 5
```

위 코드가 가능한 이유는 단항 연산자가 이항 연산자보다 우선순위를 갖기 때문이다.

### 증가/감소 연산자

**증가(increment) 연산자** `++`는 변수를 1 증가시킨다.
**감소(decrement) 연산자** `--`는 변수를 1 감소시킨다.

증가/감소 연산자는 **변수**에만 사용할 수 있으며, `5++` 와 같이 값에 사용하면 에러가 발생한다.

#### 전위형, 후위형

전위형과 후위형은 모두 변수를 1 증/감 해준다는 점에서 동일한 역할을 하지만, 해당 연산자의 반환 값을 사용할 때 차이가 드러난다.

전위형은 **증/감 후의 새로운 값**을 반환하지만, 후위형은 **증/감 전의 기존 값**을 반환한다.

`전위형`

```js
let counter = 1;
let a = ++counter; // 전위형 증가 연산자이므로 counter을 증가시키고 새로운 값을 반환한다

alert(a); // 2
```
`후위형`

```js
let counter = 1;
let a = ++counter; // 전위형 증가 연산자이므로 counter을 증가시키지만 증가 전의 기존 값을 반환한다

alert(a); // 1
```

반환 값을 사용하지 않는 경우, 전위형과 후위형은 동일하게 해당 변수의 값을 증/감한다.

값을 증/감한 후, 변경된 값을 바로 사용하려면 전위형 증가 연산자를 사용하면 된다.
값을 증/감하지만, 변경 전 값을 사용하려면 후위형 증가 연산자를 사용하면 된다.

### 비트 연산자

비트 연산자는 인수를 32비트 정수로 변환하여 이진 연산을 수행한다.

비트 연산 시 쓰이는 연산자 목록은 다음과 같다.

- 비트 AND ( `&` )
- 비트 OR ( `|` )
- 비트 XOR ( `^` )
- 비트 NOT ( `~` )
- 왼쪽 시프트(LEFT SHIFT) ( `<<` )
- 오른쪽 시프트(RIGHT SHIFT) ( `>>` )
- 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( `>>>` )

자세한 내용은 MDN의 [비트 연산자](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) 문서를 참고할 것



## 2.8) [Comparisons](https://javascript.info/comparison)

비교 연산자는 불린형 값을 반환한다.

### 동등 연산자 vs 일치 연산자

동등 연산자 (equality operator) `==` 는 `0` 과 `false`, 빈 문자열을 구별하지 못한다.

```js
alert( 0 == false ); // true
alert( '' == false ); // true
```

왜냐면 동등 연산자는 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 형변환하기 때문이다. 

이들을 구별하기 위해서는 **일치 연산자** 를 사용해야 한다.

일치 연산자 (strict equality operator) `===` 는 형 변환 없이 값을 비교할 수 있다. 일치 연산자는 엄격한 동등 연산자로서, 값 뿐만이 아니라 자료형의 동등 여부까지 검사한다.

따라서 피연산자의 형이 다를 경우 `===` 는 `false` 를 즉시 반환한다.

### null이나 undefined가 비교연산자의 피연산자가 될 때 주의하기

`null`이나 `undefined`를 다른 값과 비교할 땐 예상치 못한 일들이 발생한다.

#### 1. 일치 연산자를 사용한  `null`**과** `undefined` 비교

일치 연산자는 자료형의 동등 여부를 검사하는데, 두 값의 자료형이 다르기 때문에 일치 비교시 거짓이 반환된다.

```js
alert( null === undefined ); // false
```

### 2. 동등 연산자를 사용한  `null`**과** `undefined` 비교

동등 연산자는 `null` 과 `undefined`  를 각별한 커플처럼 취급한다. 두 값을 비교할 시 특별한 규칙이 적용되어 true 가 반환된다.

```js
alert( null == undefined ); // true
```

### 3. 기타 비교 연산자를 사용한  `null`**과** `undefined` 비교

`null`과 `undefined`는 숫자형으로 변환 될 수 있다. 각각 `null`은 `0`, `undefined`는 `NaN`으로 변환된다.

1) null 과 0을 비교하기

```js
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

동등 연산자와 그 외의 비교 연산자의 작동 방식이 다르다는 것을 이해해야 한다.

(1),(3)  `> < >= <=` 는 null을 숫자형 0으로 변환한다. 따라서 (1) 은 거짓, (3) 은 참이다.

(2) 동등 연산자 `==` 는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않는다. 오직 `undefined`와 `null`을 비교하는 경우에만 `true`를 반환하고, 그 이외의 경우 하나의 피연산자가 `null` 또는 `undefined` 라면 무조건 `false`를 반환합니다. 이런 이유 때문에 (2)는 거짓이다.

2) undefined 는 다른 값과 비교해서는 안된다.

```js
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

(1),(2) undefined는 NaN으로 변환되는데, NaN이 피연산자인 경우 비교연산자는 항상 거짓을 반환한다.

(3) undefined 를 동등 연산자로 비교할 때는 다른 피연산자가 오직 null이나 undefined 일 때만 참이고 (각별한 커플!), 그 이외의 값은 모두 다 거짓이다.



이런 엣지 케이스들을 외울 필요는 없지만, `undefined`나 `null`이 될 가능성이 있는 변수가 일치 연산자를 제외한 비교 연산자의 피연산자로 온다면 의도하지 않은 연산 결과가 나올 수 있다는 것에 주의해야 한다.

가급적 `undefined`나 `null`가 비교 연산자의 피연산자가 되지 않도록 주의하되, 만약 변수가  `undefined`나 `null`이 될 가능성이 있다고 판단되면 `null/undefined` 여부를 확인하는 코드를 따로 추가하는 습관을 들여야 한다.



## 2.9) [Interaction: alert, prompt, confirm](https://javascript.info/alert-prompt-confirm)

브라우저 환경에서 사용되는 최소한의 사용자 인터페이스 기능 중, 브라우저가 제공해주는 함수인  `alert`, `prompt`, `confirm`에 대해 알아볼 것이다.

### alert

```js
alert("Hello");
```

메시지를 보여주는 모달 창을 띄우며, 사용자가 확인 버튼을 누를 때까지 메시지는 계속 떠 있고 스크립트의 실행이 일시적으로 중단된다.

### prompt

```js
let age = prompt('나이를 입력해주세요.', 100);

alert(`당신의 나이는 ${age}살 입니다.`); // 당신의 나이는 100살입니다.
```

Prompt 함수는 2개의 인수 (title, [default]) 값을 받는다.

- Title: 모달 창에 띄워 사용자에게 보여줄 문자열
- Default: 입력 필드의 초깃값 (선택사항이지만 IE에서는 이를 생략할 경우 초기값으로 "undefined" 가 들어가므로 꼭 빈 문자열을 초기값으로 전달해줄 것)

사용자는 prompt의 대화 상자에 원하는 값을 입력하고 확인을 누르거나, 취소 버튼 혹은 ESC로 대화 상자를 반환할 수 있다.

prompt 는 사용자가 입력한 문자열을 반환하고, 사용자가 입력을 취소한 경우는 null을 반환한다.

### confirm

```js
let isBoss = confirm("당신이 주인인가요?");

alert( isBoss ); // 확인 버튼을 눌렀다면 true가 출력됩니다.
```

confirm 함수는 매개변수로 받은 질문과, 확인 및 취소 버튼이 있는 모달 창을 보여준다.

사용자가 확인 버튼을 누르면 true, 그 외의 경우는 false를 반환한다.

### 모달 창

모달 창이 떠 있는 동안은 스크립트의 실행이 일시 중단되고, 사용자가 창을 닫기 전까진 나머지 페이지와 상호작용이 불가능하다.

커스텀 모달과는 달리 위 함수들의 모달 창의 위치와 모양은 브라우저에 의해 결정된다는 제약사항이 있다. (개발자가 수정할 수 없다.)



## 2.10) [Conditional operators: if, '?'](https://javascript.info/ifelse)

### 물음표 연산자와 if

if 대용으로 물음표 연산자를 사용하는 것은 가능하지만, 바람직하지 않다.

여러 분기를 만들어 처리할 때는 if 연산자를 사용하고, 조건에 따라 반환 값을 달리할 때는 물음표 연산자를 사용하는 것이 좋다.



## 2.11) [Logical operators](https://javascript.info/logical-operators)

자바스크립트엔 세 종류의 논리 연산자 `||`(OR), `&&`(AND), `!`(NOT)가 있다. 논리 연산자는 피연산자로 불린형 뿐만 아니라 모든 타입의 값을 받을 수 있다.

### 첫 번째 truthy를 찾는 OR 연산자  '||'

전통적인 OR 연산자의 기능 외에도, 자바스크립트에서 제공하는 논리연산자 OR의 추가 기능을 활용하면 편리하다.

#### OR 연산자와 피연산자가 여러 개인 경우의 알고리즘

```js
result = value1 || value2 || value3;
```

- 가장 왼쪽 피연산자부터 가장 오른쪽 피연산자까지 평가한다
- 각 피연산자를 불린형으로 변환한 후, 변환값이 `true` 이면 연산을 멈추고 해당 피연산자의 **변환 전 원래 값을 반환**한다.
- 피연산자 모두가 `false` 로 평가되는 경우엔 마지막 피연산자의 원래 값을 반환한다.

즉, OR 연산자는 첫 번째 truthy를 반환하고, 피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환한다.

#### 용례

1. null 또는 undefined 일 수 있는 여러 변수 또는 표현식 목록에서 첫 번째 truthy 얻기
2. 단락 평가 (short circuit evaluation) - truthy를 만난 순간 평가를 멈춘 후 값을 반환하기에, 모든 피연산자를 평가하지 않고 짧게 연산을 끝마칠 수 있다.

### 첫 번째 falsy를 찾는 AND 연산자 ‘&&’

OR 연산자와 마찬가지로, 전통적인 AND 연산자의 기능 외에도, 자바스크립트에서 제공하는 논리연산자 AND의 추가 기능을 활용하면 편리하다.

#### AND 연산자와 피연산자가 여러 개인 경우의 알고리즘

- 가장 왼쪽 피연산자부터 가장 오른쪽 피연산자까지 평가한다
- 각 피연산자를 불린형으로 변환한 후, 변환값이 `false` 이면 연산을 멈추고 해당 피연산자의 **변환 전 원래 값을 반환**한다.
- 피연산자 모두가 `true` 로 평가되는 경우엔 마지막 피연산자의 원래 값을 반환한다.

즉,  AND 연산자는 첫 번째 falsy를 반환하고, 피연산자에 falsy가 하나도 없다면 마지막 피연산자를 반환한다.

+) `&&` 의 우선순위가 `||` 보다 높다.

### ! (NOT) 연산자

NOT 연산자는 하나의 인수를 받아 다음 순서대로 연산을 수행한다.

1. 피연산자를 불린형으로 변환한다
2. 1에서 변환된 값의 역을 반환한다

NOT을 두개 연달아 사용하면 (`!!`) 값을 불린형으로 변환할 수 있다. 내장 함수 `Boolean` 을 사용한 명시적 형변환과 같은 역할을 수행한다.

```js
alert( !!"non-empty string" ); // true
alert( !!null ); // false

alert( Boolean("non-empty string") ); // true
```



## 2.12) [Loops: while and for](https://javascript.info/while-for)

### break/continue와 레이블

break는 한개의 반복문만 빠져나올 수 있다. 여러 개의 중첩 반복문을 한 번에 빠져나와야 할 경우, **lable 식별자**를 사용해 한 번에 여러개의 반복문을 빠져나올 수 있다.

레이블은 반복문 앞에 콜론과 함께 사용하며, 레이블을 별도의 줄에 써 주는 것도 가능하다.

```js
labelName: for (...) {
  ...
}
// 또는
outer:
for (let i = 0; i < 3; i++) { ... }
```



## 2.13) [The "switch" statement](https://javascript.info/switch)

복수의 if 조건문을 하나의 switch 문으로 바꿀 수 있다.

```js
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]
	// default 문은 필수가 아니다.
  default:
    ...
    [break]
}
```

주의할 점은, case 문 안에 break 가 없다면 **조건에 부합하는지 여부를 따지지 않고 이어지는 case 문을 실행**한다는 것이다.

```js
let a = 4;

switch (a) {
  case 3:
    alert( '비교하려는 값보다 작습니다.' );
  case 4:
    alert( '비교하려는 값과 일치합니다.' );
  case 5:
    alert( '비교하려는 값보다 큽니다.' );
  default:
    alert( "어떤 값인지 파악이 되지 않습니다." );
}
```

위 예시를 실행하면, case 문 안에 break가 없기 때문에 아래 3개의 alert 문이 모두 실행된다.

```js
alert( '비교하려는 값과 일치합니다.' );
alert( '비교하려는 값보다 큽니다.' );
alert( "어떤 값인지 파악이 되지 않습니다." );
```

#### 자료형이 중요한 switch 문

switch 문은 동등 비교 (`==`)가 아닌 일치 비교 (`===`) 로 조건을 확인한다. 비교하려는 값과 case 문의 값과 자료형이 모두 같아야 해당 case 문이 실행된다.

```js
let arg = prompt("값을 입력해주세요.");
switch (arg) {
  case 3:
    alert( '이 코드는 절대 실행되지 않습니다!" );
    break;
  default:
    alert( '알 수 없는 값을 입력하셨습니다.' );
}
```

prompt 는 사용자가 입력 필드에 기재한 값을 문자열로 변환해 반환하기에, 사용자가 숫자 3을 입력하더라도 문자열 "3" 을 반환한다.

따라서 사용자가 3을 입력할 경우 case 3은 절대 실행되지 않고, 위 코드에서는 default문이 실행된다.  문자열 "3"과 숫자 3은 형이 다르기 때문이다.



## 2.14) [Functions](https://javascript.info/function-basics)

### 외부변수, 지역변수, 매개변수

함수는 외부변수에 접근할 수 있다. 하지만 함수 바깥에서 함수 내부의 지역변수에 접근하는 것은 불가능하다.

함수 내부에서 외부변수를 사용하는 것 보단, 지역변수와 매개변수만을 활용하는 것이 좋다. (매개변수 없이 함수 내부에서 외부 변수를 수정해 반환값을 만들어내는 함수는 쉽게 이해하기 힘들다.)

함수에 전달된 매개변수는 **복사된 후 함수의 지역변수**가 된다. 따라서 함수에 외부변수를 매개변수로 받아 그 값을 함수 내에서 변경하더라도, 외부변수는 변경되지 않는다.

```js
function showMessage(from, text) {

  from = '*' + from + '*'; // 함수 내에서 매개변수를 변경하고 있다

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// 함수는 복사된 값을 사용하기 때문에 외부변수 from은 값이 변경되지 않는다
alert( from ); // Ann
```

### 매개변수의 기본값

매개변수에 값을 전달하지 않으면 그 값은 `undefined` 가 된다.

매개변수의 기본값을 설정해주려면 매개변수 오른쪽에 `=` 를 붙이고 기본값을 설정해주면 된다.

```js
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

두 번째 인수를 전달하지 않아도 undefined 대신 기본값이 할당되는 것을 알 수 있다.

### 반환값

`return` 지시자를 통해 함수를 호출한 곳에 특정 값을 반환하게 할 수 있다.
return은 함수 내 어디서든 사용할 수 있으며, 함수 실행 중 return을 만나면 함수 실항은 즉시 중단되고 함수를 호출한 곳에 값을 반환한다.

return 문이 없거나, return 지시자만 있는 함수는 undefined를 반환한다.

```js
function doNothing() { /* 빈 함수 */ }

alert( doNothing() === undefined ); // true

/* return 지시자만 있는 함수는 return undefined와 동일하게 동작한다 */
function doNothing2() {
  return;
}

alert( doNothing2() === undefined ); // true
```

#### 긴 표현식을 return 하고 싶은 경우

함수가 반환하려는 값이 줄을 새 줄을 포함한 긴 표현식일 경우,  괄호 `()` 를 사용해야 한다.

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

괄호 없이 새 줄을 포함한 표현식을 return 하면, return 문 끝에 세미콜론이 자동으로 삽입되기에 반환하고자 했던 표현식을 의도한 대로 반환하지 못한다.

### 함수 명명법

함수는 어떤 동작을 수행하기 위한 코드를 모아놓은 것이기 때문에, 함수의 이름은 대개 **동사**로 짓는다.

아래와 같은 접두어들을 사용하여 함수 이름을 지을 수 있다.

- `"get…"` – 값을 반환함,
- `"show..."` - 무언가를 보여줌,
- `"calc…"` – 무언가를 계산함,
- `"create…"` – 무언가를 생성함,
- `"check…"` – 무언가를 확인하고 불린값을 반환함.

### 함수는 동작 하나만 담당해야 한다

함수는 간결해야 하고, **함수 이름에 언급되어 있는 기능 하나만 정확하게 수행**하는 것이 좋다. 

예를 들어, getAge 라는 함수는 나이를 얻어오는 동작만 수행하고, 나이를 출력해주는 동작은 이 함수에 들어가지 않는 것이 좋다.



## 2.15) [Function expressions](https://javascript.info/function-expressions)

자바스크립트의 함수는 1급 객체이다.

### 함수를 만드는 방법

#### 함수 선언문

```js
function sayHi() {
  alert( "Hello" );
}
```

#### 함수 표현식

```js
let sayHi = function() {
  alert( "Hello" );
};
```

함수는 값이고, 따라서 변수에 할당할 수 있다. 다만, 함수 이름 옆에 괄호 `()` 가 있다면 함수를 호출할 수 있기 때문에 함수는 특별한 종류의 값이다.

하지만 함수의 본질은 값이므로 값에 할 수 있는 일들을 함수에도 할 수 있다.

```js
function sayHi() {   // (1) 함수 생성
  alert( "Hello" );
}

let func = sayHi;    // (2) 함수를 새로운 변수 func에 복사

func(); // Hello     // (3) 복사한 함수를 실행
sayHi(); // Hello    //     본래 함수도 정상적으로 실행
```

만약 (2) 번에서

```js
let func = sayHi();
```

처럼 괄호가 있었다면, sayHi 함수 자체가 아닌 sayHi 함수의 반환값이 func에 저장되었을 것이다.

### 함수 표현식 vs 함수 선언문

#### JS 엔진의 함수 생성 시점

두 함수 생성 방식의 첫번째 차이는 문법 외에도, **자바스크립트 엔진이 언제 함수를 생성하는지**에 있다.

1) 함수 표현식

함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있다.

```js
sayHi("John"); // error!

let sayHi = function(name) {  // 함수 표현식으로 정의한 함수는 함수가 선언된 시점 이후부터 사용할 수 있다.
  alert( `Hello, ${name}` );
};
```

2) 함수 선언문

함수 선언문으로 생성된 함수는 **함수 선언문이 정의되기 전에도 호출할 수 있다.** 따라서 전역 함수 선언문은 스크립트 어디에서든 사용할 수 있다.

그 이유는 자바스크립트의 내부 알고리즘 때문인데, 자바스크립트는 스크립트를 실행하기 전 준비단계에서 전역에 선언된 함수 선언문을 찾고, 해당 함수를 생성한다.

스크립트는 준비단계가 끝난 이후에 실행되므로, 스크립트 어디서든 함수 선언문으로 선언한 함수에 접근할 수 있다.

```js
sayHi("John"); // Hello, John

function sayHi(name) { // 전역 함수 선언문으로 정의한 함수는 스크립트 실행 전 준비단계에서 미리 생성되기에, 스크립트 어디서든 함수 선언문으로 선언한 함수에 접근할 수 있다.
  alert( `Hello, ${name}` );
}
```

#### 스코프

엄격 모드에서, 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 하지만, 블록 밖에서는 함수에 접근할 수 없다.



함수 선언문으로 함수를 정의하면, 함수가 선언되기 전에 호출할 수 있어서 코드 구성을 좀 더 자유롭게 할 수 있고 가독성도 좋아진다.

어떠한 이유로 함수 선언 방식이 적합하지 않을 경우 함수 표현식을 사용하는 것을 고려하는 것이 바람직하다.



## 2.16) [Arrow functions, the basics](https://javascript.info/arrow-functions-basics)

### 함수 본문이 한 줄인 경우

화살표 함수는 본문이 한 줄인 간단한  함수를 작성할 때 유용하다.

```js
let sum = (a,b) => a+b
```

위 화살표 함수는 아래와 같은 역할을 한다.

```js
let sum = function(a,b) {
  return a+b;
}
```

### 함수 본문이 여러줄인 경우

평가해야 할 표현식이나 구문이 여러개인 함수인 경우, 중괄호 `{}` 안에 평가해야 할 코드를 넣어준 뒤 return 지시자를 사용해 명시적으로 결과값을 반환해줘야 한다.

```js
let sum = (a, b) => {  // 중괄호는 본문 여러 줄로 구성되어 있음을 알려준다
  let result = a + b;
  return result; // return 지시자를 사용해 명시적으로 결괏값을 반환
};

alert( sum(1, 2) ); // 3
```



## 2.17) [JavaScript specials](https://javascript.info/javascript-specials)

복습 단원이므로 생략한다.