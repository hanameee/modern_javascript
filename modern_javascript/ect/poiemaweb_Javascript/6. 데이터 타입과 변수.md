# [6. 데이터 타입과 변수](https://poiemaweb.com/js-data-type-variable)

출처 : [poiemaweb](https://poiemaweb.com/)

메모리에 값을 저장하기 위해서는 먼저 메모리 공간을 확보해야 할 메모리의 크기(byte)를 알아야 한다. 값의 종류 (데이터 타입) 에 따라 확보해야 할 메모리의 크기가 다르기 때문이다.

C와는 달리, 자바스크립트는 동적 타입 (Dynamic / Weak Type) 언어이다. 별도의 변수의 타입 지정 없이, 값이 할당되는 과정에서 자동으로 변수의 타입이 결정된다. 변수 자체엔 고정된 타입이 없기에 같은 변수에 여러 타입의 값을 자유롭게 할당할 수 있다.

## 1. 데이터 타입

데이터 타입은 데이터를 메모리에 저장할 때 확보해야 하는 메모리 공간의 크기와 할당할 수 있는 유효한 값에 대한 정보, 그리고 메모리에 저장되어 있는 **2진수 데이터를 어떻게 해석**할 지에 대한 정보를 컴퓨터와 개발자에게 제공한다.

자바스크립트에서 제공하는 7개의 데이터 타입은 크게 원시 타입와 객체 타입으로 구분할 수 있다.

### 1.1 원시 타입 (Primitive Data Type)

원시 타입의 값은 변경 불가능한 값 (immutable) 이며, 값에 의한 전달 (pass by value) 이 된다.

####number

자바스크립트는 하나의 숫자 타입 (실수) 만 존재한다. 모든 숫자가 동일하게 배정밀도 64비트 부동소수점 형식의 2진수로 메모리에 저장된다. 정수로 표시된다고 해도 사실은 실수다.

```js
console.log(1 === 1.0); // true

var result = 4 / 2;
console.log(result); // 2
result = 3 /2;
console.log(result); // 1.5 정수끼리 나눠도 실수가 나올 수 있다
```

#### string

자바스크립트의 문자열은 원시 타입이며 변경 불가능하다.

```js
var str = 'Hello';
str = 'world';
```

위 코드가 끝난 후 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다. 변수 str은 문자열 ‘Hello’를 가리키고 있다가 문자열 ‘world’를 가리키도록 변경되었을 뿐, 한번 생긴 문자열은 read only (= immutable) 로서 변경되지 않는다.

문자열은 **유사 배열**이기에 인덱스를 통해 접근 할 수 있지만, `str[0] = 'S'` 처럼 이미 생성된 문자열의 일부 문자를 변경해도  반영되지 않는다.

#### undefined

선언 이후 값을 할당하지 않은 변수는 `undefined` 값을 가진다. undefined는 개발자가 의도적으로 할당한 값이 아니라 **자바스크립트 엔진에 의해 초기화된 값**이다. 따라서 개발자가 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적인 없는 변수라는 것을 알 수 있다.

그렇기에 개발자가 의도적으로 undefined를 선언하는 것은 undefined의 본래 취지와 어긋나고, 혼란을 줄 수 있기에 권장하지 않는다. undefined는 자바스크립트 엔진이 변수 초기화에 사용하는 값이라는 것을 기억하자.

#### null

null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 혹은, 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우 null을 반환하기도 한다.

### 1.2 객체 타입 (Object type, Reference type)

변수는 `var`, `let`, `const` 키워드를 사용하여 **선언**하고 할당 연산자를 사용해 값을 **할당**한다. 그리고 식별자인 변수명을 사용해 변수에 저장된 값을 **참조**한다.

## 2. 변수

### 변수 호이스팅

**자바스크립트에서 모든 선언문은 호이스팅**된다.
호이스팅이란, 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉, 자바스크립트는 모든 선언문(var, let, const, function, class)이 **선언되기 이전에 참조 가능**하다.

변수는 아래 3단계에 걸쳐 생성된다.

**1) 선언 단계**
변수 객체 (variable object) 에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.
**2) 초기화 단계**
변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 `undefined`로 초기화된다.
**3) 할당 단계**
undefined로 초기화된 변수에 실제 값을 할당한다.

```js
console.log(foo); // ① undefined
var foo = 123;
console.log(foo); // ② 123
{
  var foo = 456;
}
console.log(foo); // ③ 456
```

var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 스코프에 변수가 등록되고, 변수는 메모리에 공간을 확보한 후 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근해도 변수 객체에 변수가 존재하기에 에러가 발생하지 않고 undefined를 반환한다. 이후 변수 할당문 (var foo = 123) 에 도달하면 비로소 값의 할당이 이루어진다.

#### 함수 레벨 스코프 vs 블록 레벨 스코프

자바스크립트의 **var** 키워드를 사용한 변수는 **함수 레벨 스코프**를 가진다. 단, ES6에서 도입된 **let, const** 키워드를 사용하면 **블록 레벨 스코프**를 사용할 수 있다.

> 함수 레벨 스코프: 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.

> 블록 레벨 스코프 : 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.
위 예제 코드에서는 var 키워드를 사용했으므로 코드 블록 내의 변수 foo는 전역변수이다.

### var 키워드로 선언된 변수의 문제점

ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다. 이는 아래와 같은 심각한 문제를 발생시킬 위험이 있었다.

1. 함수 레벨 스코프(Function-level scope)
   - 전역 변수의 남발
   - for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다.
2. var 키워드 생략 허용
   - 의도하지 않은 변수의 전역화
3. 중복 선언 허용
   - 의도하지 않은 변수값 변경
4. 변수 호이스팅
   - 변수를 선언하기 전에 참조가 가능하다.

전역변수는 불가피한 상황을 제외하고 사용을 억제해야 한다. 전역변수는 스코프가 넓어서 어디에서 어떻게 사용될 지 파악하기 힘들고, 의도치 않은 변수의 변경이 발생할 수 있기 때문이다.

변수의 스코프는 좁을수록 좋다. ES6에서는 이러한 var의 단점을 보완하기 위해 let과 const 키워드를 도입했다.