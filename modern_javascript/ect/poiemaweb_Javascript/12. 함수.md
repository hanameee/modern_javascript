# [12. 함수](https://poiemaweb.com/js-function)

출처 : [poiemaweb](https://poiemaweb.com/)

함수의 일반적 기능은 어떤 작업을 수행하는 문들의 집합을 정의하여 코드를 재사용하는 것에 목적이 있다. 이러한 일반적 기능 이외에 객체 생성, 객체의 행위 정의(메소드), 정보 은닉, 클로저, 모듈화 등의 기능을 수행할 수 있다.

**자바스크립트의 함수는 객체(일급 객체, First-class object)이다**. 다른 객체와 구분될 수 있는 특징은 호출할 수 있다는 것이다. 함수도 객체이므로 (1) 변수나 객체, 배열 등에 저장할 수 있고 (2) 다른 함수에 전달되는 인수로도 사용할 수 있으며 (3) 함수의 반환값이 될 수도 있다.

## 1. 함수 정의

함수를 정의하는 방식은 3가지가 있다.

- 함수 선언문
- 함수 표현식
- Function 생성자 함수

### 1.1 함수 선언문

함수 선언문 방식으로 정의한 함수는 `function` 키워드와 아래 요소들로 구성된다.

함수명 : 함수 선언문의 경우 함수명은 생략할 수 없다

매개변수 목록 : 0개 이상의 목록으로, 괄호로 감싸고 콤바로 분리한다.

함수 몸체 : 함수가 호출되었을 때 실행되는 문들의 집합이다. 중괄호 `{ }` 로 문들을 감싸고 `return` 문으로 결과값을 반환할 수 있다.

```js
// 함수 선언문
function square(number) {
  return number * number;
}
```

### 1.2 함수 표현식

변수에 저장할 수 있는 함수의 일급객체 특성을 이용하여, 함수 리터럴 방식으로 함수를 정의하고 변수에 할당할 수 있는데 이러한 방식을 함수 표현식(Function expression)이라 한다.

함수 표현식 방식으로 정의한 함수는 함수명을 생략할 수 있다. 이러한 함수를 **익명 함수(anonymous function)**이라 한다. 함수 표현식에서는 함수명을 생략하는 것이 일반적이다.

```js
// 함수 표현식
var square = function(number) {
  return number * number;
};
```

### 1.3 Function 생성자 함수

함수 선언문과 함수 표현식은 모두 **함수 리터럴 방식**으로 함수를 정의하는데, 이는 결국 내장 함수 Function 생성자 함수로 함수를 생성하는 것을 단순화시킨 축약법이다.

따라서 Function 생성자 함수로 함수를 생성하는 방식은 일반적으로 사용하지 않는다.

[Function 생성자 함수 문법]

```js
new Function(arg1, arg2, ... argN, functionBody)
```

[Function 생성자 함수 사용 예시]

```js
var square = new Function('number', 'return number * number');
console.log(square(10)); // 100
```

## 2. 함수 호이스팅

함수 정의 방식에 따라 호이스팅이 달라진다.

자바스크립트는 ES6의 let, const를 포함하여 **ES6의 let, const를 포함하여 모든 선언(var, let, const, function, function\*, class)을 호이스팅한다.**

### 함수 선언문의 호이스팅

**함수 선언문**으로 정의된 함수는 **함수 호이스팅**이 발생한다.
함수 호이스팅이란, 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 변수 객체(variable object)에 저장한다는 것이다. 즉, **함수 선언(생성), 초기화, 할당이 한번에 이루어진다.**

그렇기 때문에 함수 선언문으로 생성된 함수는, 선언문의 위치와는 상관없이 **소스 내 어느 곳에서든지 호출이 가능**하다.

### 함수 표현식의 호이스팅

**함수 표현식**의 경우 함수 호이스팅이 아니라 **변수 호이스팅**이 발생한다. 변수 생성, 초기화, 할당이 한번에 이루어지는 함수 선언문과는 달리, 변수 호이스팅은 (1)변수 생성 및 초기화와 (2)할당이 분리되어 진행된다.

호이스팅된 변수는 변수 생성 및 초기화만 진행되고, **할당문을 만났을 때 실제 값이 할당이** 이루어진다.

이처럼 함수 표현식은 함수 선언문과는 달리, 스크립트 로딩 시점에 변수 객체에 함수를 할당하지 않고 runtime에 해석되고 실행되므로 큰 차이가 있다.

### 함수 선언문의 단점

1. 혼란을 일으키는 함수 호이스팅

   자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 함수 호이스팅의 특징을 가지는 함수 선언문 때문에 **함수 표현식만을 사용할 것을 권고**하고 있다. 함수 호이스팅이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시해 코드의 구조를 엉성하게 만들 수 있기 때문이다. (함수 선언문이 나오기 전에도 어디서든지 호출할 수 있으므로)

2. 성능 이슈

   또, 함수 선언문은 사용하긴 쉬울 지 몰라도 스크립트 로딩 시점에 함수를 변수 객체에 저장하므로, 대규모 애플리케이션을 개발하는 경우 인터프리터가 너무 많은 코드를 변수 객체에 저장해 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 한다.

## 3. 일급 객체

일급 객체(first-class object)란 **생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상**을 의미한다.

다음 조건을 만족하면 일급 객체로 간주한다.

> 1. 무명의 리터럴로 표현이 가능하다.
> 2. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
> 3. 함수의 매개변수에 전달할 수 있다.
> 4. 반환값으로 사용할 수 있다.

자바스크립트 함수는 위의 4가지 조건을 모두 만족하므로 일급 객체이다. 함수와 다른 객체를 구분짓는 유일한 특징은 호출할 수 있다는 것이다.

## 4. 매개변수

### 4.1 매개변수(parameter, 인자) vs 인수(argument)

인수(argument)는 함수를 호출할 때 넘겨주는 값, 매개변수(parameter)는 함수가 외부에서 전달받은 값을 의미한다.

매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 외부에서 함수에 전달한 인수는 매개변수에 할당된다. 인수를 전달하지 않으면 매개변수는 undefined로 초기화된다.

```js
var foo = function (p1, p2) {
  console.log(p1, p2);
};

foo(1); // 1 undefined
```

### 순수함수란?

원시 타입 인수는 **Call-by-value**(값에 의한 호출)로 동작한다. 함수 호출 시 원시 타입 인수를 전달하면 복사된 매개변수를 통해 함수 내에서 값이 변경되어도 전달된 원시 타입 값은 변경되지 않는다.

```js
function foo(primitive) {
  primitive += 1;
  return primitive;
}

var x = 0;

console.log(foo(x)); // 1 - 매개변수는 복사되어 변경 사항이 반영된다
console.log(x);      // 0 - 변경되지 않는다
```

객체형 인수는 **Call-by-reference**(참조에 의한 호출)로 동작한다. 함수 호출 시 참조 타입 인수를 전달하면 매개변수에 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 전달된다. 함수 내에서 값이 변경되면 전달된 참조형의 인수 값도 같이 변경된다.

원시 타입 인수는 값을 복사하여 매개변수에 전달하기 때문에 함수 몸체에서 값을 변경해도 어떠한 side effect 도 일어나지 않는다.

하지만 객체형 인수는 참조값을 매개변수에 전달하기 때문에 함수 몸체에서 그 값을 변경할 경우 원본 객체가 변경되는 side effect 가 발생한다.

어떤 외부 상태도 변경하지 않는 함수를 순수함수(Pure function), 외부 상태도 변경시켜는 부수 효과(side-effect)가 발생시키는 함수를 비순수 함수(Impure function)라 한다. 순수함수는 side effect가 없기에 디버깅이 쉽다.

## 5. 반환값

함수는 `return` 키워드를 통해 caller에게 값을 반환할 수 있다.

반환을 생략하면 함수는 암묵적으로 undefined를 반환한다.

## 6. 함수 객체의 프로퍼티

### arguments 프로퍼티

자바스크립트는 **함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달**된다. arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 **유사배열객체(array-like object)**이다. 

#### 참고) 유사배열객체란?

유사배열객체란 length 프로퍼티를 가진 객체를 말한다. 유사배열객체는 배열이 아니므로 배열 메소드 (map, reduce...등)를 사용하는 경우 에러가 발생하게 된다. 따라서 배열 메소드를 사용하려면 `Array.prototype.call` 등을 통해 배열로 변환한 뒤 사용해야 한다.



```js
function sum() {
  var res = 0;
	// 암묵적으로 arguments 객체가 전달된다.
  for (var i = 0; i < arguments.length; i++) {
    res += arguments[i];
  }

  return res;
}

console.log(sum());        // 0
console.log(sum(1, 2));    // 3
console.log(sum(1, 2, 3)); // 6
```

### \_\_proto\_\_ 접근자 프로퍼티

모든 객체는 **[[Prototype]]**이라는 내부 슬롯이 있다. [[Prototype]] 내부 슬롯은 **프로토타입 객체**를 가리킨다. 

#### 프로토타입 객체란?

객체 간의 상속을 구현하기 위해 사용된다. 프로토타입 객체는 다른 객체에 공유 프로퍼티를 제공하는 객체를 말한다.

`__proto__` 프로퍼티는 이 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 내부 슬롯에 직접 접근은 불가능하고, 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있는데, [[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 `__proto__` 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다.

```js
// 객체 리터럴로 생성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log({}.__proto__ === Object.prototype); // true
```

주의할 점은,  `__proto__` 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니다.

```js
console.log(Object.getOwnPropertyDescriptor({}, '__proto__'));
// undefined
```

 `__proto__` 프로퍼티는 모든 객체의 프로토타입 객체인 **Object.prototype** 객체의 프로퍼티이다. 모든 객체는 상속을 통해  `__proto__` 접근자 프로퍼티를 사용할 수 있는 것이다.

```js
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}
```

**함수 역시 객체**이므로,  `__proto__` 접근자 프로퍼티를 통해 프로토타입 객체에 접근할 수 있다. 함수 객체의 프로토타입 객체는 **Function.prototype**이다.

```js
console.log((function() {}).__proto__ === Function.prototype); // true
```

### prototype 프로퍼티

prototype 프로퍼티는 **함수 객체만이 소유**하는 프로퍼티이다. (일반 객체에는 prototype 프로퍼티가 없다.)

prototype 프로퍼티는 **함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성한 인스턴스의 프로토타입 객체**를 가리킨다.



## 7. 함수의 다양한 형태

### 7.1 즉시 실행 함수 (IIFE, Immediately Invoke Function Expression)

함수의 정의와 동시에 실행되는 함수를 즉시 실행 함수(IIFE)라고 한다.

```js
// SyntaxError: Unexpected token (
// 함수선언문은 자바스크립트 엔진에 의해 함수 몸체를 닫는 중괄호 뒤에 ;가 자동 추가된다.
function () {
  // ...
}(); // => };();

// 따라서 즉시 실행 함수는 소괄호로 감싸주어야 한다.
(function () {
  // ...
}());

(function () {
  // ...
})();
```

IIFE는 변수명 또는 함수명의 충돌을 방지하기 위한 목적으로 사용되기도 한다. 코드를 즉시 실행 함수 내에 정의해 두면 변수들이 독립된 영역 내에 있게 되기 때문이다.

```js
(function () {
  var foo = 1;
  console.log(foo); // 1
}());

var foo = 100;
console.log(foo); // 100
```

### 7.2 내부 함수

함수 내부에 정의된 함수를 내부함수라고 한다.
내부함수는 자신을 포함하고 있는 부모함수의 변수에 접근할 수 있으나, 부모함수는 내부함수의 변수에 접근할 수 없다.

또한 내부함수는 부모함수의 외부에서 접근할 수 없다.

### 7.3 재귀함수

재귀함수는 자기 자신을 호출하는 함수를 말하며, 함수가 무한 호출되면 stackoverflow가 발생할 수 있으므로 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.

### 7.4 콜백함수

콜백 함수는 함수를 명시적으로 호출하는 방식이 아니라, 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다.

콜백 함수가 자주 사용되는 대표적인 예는 이벤트 핸들러 처리이다.

```js
var button = document.getElementById('myButton');
button.addEventListener('click', function() {
  console.log('button clicked!');
});
```

콜백함수는 매개변수를 통해 전달되고, 전달받은 함수의 내부에서 **어느 특정시점**에 실행된다.

이런 콜백함수는 주로 비동기식 처리 모델에 사용된다.

#### 비동기식 처리 모델이란?

비동기식 처리 모델이란 콜백함수(처리가 종료하면 호출될 함수)를 미리 매개변수에 전달하고, 처리가 종료하면 콜백함수를 호출하는 것이다.

콜백함수는 콜백 큐에 들어가 있다가, 해당 이벤트가 발생하면 호출된다. 콜백함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도, 콜백함수를 전달받은 함수의 변수에 접근할 수 있다.

```js
function doSomething() {
  var name = 'Lee';

  setTimeout(function () {
    console.log('My name is ' + name);
  }, 100);
}

doSomething(); // My name is Lee
```

